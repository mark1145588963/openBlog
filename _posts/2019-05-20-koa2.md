---
layout: post
title: "koa2一部分源码的解析"
subtitle: 'koa2 source code analysis'
author: "markzhang"
header-style: text
tags:
  - node koa2
---

从18年下半年以来开始涉足node开发以来，算起来使用koa2也快接近一年了。在使用koa2过程中对于项目由陌生到熟悉，于是想着写一篇总结来归纳自己对于koa2的理解和认识。 

这篇文章会按照以下五个模块进行组织：中间件机制、context对象、request对象、response对象、启动服务。

## 中间件机制
我们通常在项目是通过以下方式来使用中间件的
```javascript
let bodyParser = require('koa-bodyparser')
app.use(bodyParser({
  forLimit: '4mb'
}));
```
我们可以猜想到use这个函数的作用是对要运行的中间件进行收集，那让我们来看一下源码
```javascript
function use(fn) {
  if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');
  // 新版本的koa使用了async wait的语法，所以检测generator函数进行转化，并引导用户使用新的语法
  if (isGeneratorFunction(fn)) {
    deprecate('Support for generators will be removed in v3. ' +
                'See the documentation for examples of how to convert old middleware ' +
                'https://github.com/koajs/koa/blob/master/docs/migration.md');
    fn = convert(fn);
  }
  // this.middleware是一个数组，存放中间件函数
  this.middleware.push(fn);
  return this;
}
```
在收集到中间件之后，自然要对其进行组织，在koa2里面使用的koa-compose这个包进行组织的，所以让我们进入这个模块一探究竟。
```javascript
function compose(middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware must be an array!');
  for (const fn of middleware) {
    if (typeof fn != 'function') {
      throw new TypeError('Middleware must be composed of functions!');
    }
  }
  return function(context, next) {
    let index = -1;
    return dispatch(0);
    function dispatch(i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'));
      index = i;
      let fn = middleware[i];
      if(i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject();
      }
    }
  }
}

/**
 *  从上面函数来看，compose函数里面相当于是绑定了中间件的执行关系
 * 具体的中间件函数调用还是在具体的中间件中执行的。
 * koa中间件之所以能按照洋葱圈的模式运行，是因为每一个await next()相当于是跑到了下一个中间件去执行代码，
 * 一直要到最后一个中间件执行完毕，最深层的await拿到返回值，才会一层一层返回最初的中间件，有点类似于递归。
**/
// 看下下面的例子
let a = async (ctx, netx) => {
  console.log(1);
  await next();
  // 1、这两个函数相当于是同一个compose函数里面得到的dispatch(null, i + 1)
  // 2、为什么不允许存在多次next调用呢，因为洋葱圈只执行一次，执行多次没有意义
  // 3、洋葱圈模型也只是js的调用过程
  // 4、每一个netx都是下一个中间件
  // await next();
  console.log(4);
}

let b = async (ctx, next) => {
  console.log(2);
  await next();
  console.log(3);
}
// 执行之后打印出1 2 3 4
```
通过查看上面的代码中我们已经清晰的梳理出koa2中间件的收集和运行模式啦。。。